#!/usr/bin/env python2.7

"""
Author: Alexander Lin (alxlin@ucdavis.edu)
Python version of xml_to_apfeed.php
Inputs: XMLs
Output: Apfeeds
Reads exported XML generated by Alma for ERP finanical system
Creates an apfeed file and uploads it
"""

import argparse
import ConfigParser
import datetime
import logging
import os
import shutil
import re
import sys
import time
import xml.etree.ElementTree as ET

import paramiko

from scp import SCPClient

# Read config from config.ini
SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))
CONFIG_PATH = os.path.join(SCRIPT_DIR, 'config.ini')
CONFIG = ConfigParser.ConfigParser()
CONFIG.readfp(open(CONFIG_PATH))

NSP = {'exl': 'http://com/exlibris/repository/acq/invoice/xmlbeans'}


def strstr(haystack, needle):
    """
    Python version of php str str
    """
    pos = haystack.upper().find(needle.upper())
    if pos < 0:
        return haystack
    else:
        return haystack[:pos] + "}"


def create_ssh_client(scp_server, scp_user, scp_key_file):
    """
    Creates SSH Client for SCP
    """
    client = paramiko.SSHClient()
    client.load_system_host_keys()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    client.connect(scp_server, username=scp_user, key_filename=scp_key_file)
    return client


class Apfeed(object):
    """Class to model what apfeed should be generated"""
    def __init__(self):
        """Initialization"""
        self.now = datetime.datetime.now()
        self.count = 0
        self.invoices = []
        self.org_doc_nbr = int(CONFIG.get("apfeed", "org_doc_nbr"))
        self.emp_ind = 'N'
        self.errors = 0

    def add_inv(self, inv):
        """
        Add invoice to apfeed file
        Apfeed file format as follows:
        'GENERALLIBRARY AAAAAAAAAAAAAABBBBBBBCDDDDDDDDDDDEEEEEEEEEEEEEE'
        'FFFFFFFFGGGGGGGGGGGGGG                                          '
        '               HHHHHHHHHIIIIIIIIII JJK     LLLLLLLLMNOOOOO3 '
        'QQQQQQQ     RRRR          SSSSSSSSTUUUUUUUUUUUUVW             '
        '                           '
        Values  | Position   | Description
        A       | 15  - 29   | time now in %Y%m%d%H%M%S
        B       | 29  - 36   | ORG_DOC_NBR
        C       | 36  - 37   | EMP_IND
        D       | 37  - 47   | VEND_CODE
        E       | 47  - 62   | VEND_ASSIGN_INV_NBR
        F       | 62  - 70   | VEND_ASSIGN_INV_DATE
        G       | 70  - 84   | ADDR_SELECT_VEND_NBR
        H       | 308 - 316  | GOODS_RECEIVED_DT
        I       | 316 - 327  | ORG_SHP_ZIP_CD
        J       | 327 - 329  | ORG_SHP_STATE_CD
        K       | 329 - 330  | PMT_GRP_CD
        L       | 335 - 343  | SCHEDULED_PMT_DT
        M       | 343 - 344  | PMT_NON_CHECK_IND
        N       | 344 - 345  | ATTACHMENT_REQ_IND
        O       | 345 - 350  | PMT_LINE_NBR
        P       | 350 - 351  | FIN_COA_CD
        Q       | 352 - 359  | ACCOUNT_NBR
        R       | 364 - 368  | FIN_OBJECT_CD
        S       | 381 - 389  | ORG_REFERENCE_ID
        T       | 389 - 390  | PMT_TAX_CD
        U       | 390 - 402  | PMT_AMT
        V       | 402 - 403  | APPLY_DISC_IND
        W       | 403 - 404  | EFT_OVERRIDE_IND
        """

        self.org_doc_nbr += 1
        # Foreach of the invoice lines
        vend_nbr = inv.find("exl:vendor_additional_code", NSP).text
        vend_assign_inv_nbr = inv.find("exl:invoice_number", NSP).text
        logging.debug("Invoice Number: %s", vend_assign_inv_nbr)
        vend_assign_inv_date = datetime.datetime.strptime(
            inv.find("exl:invoice_date", NSP).text,
            "%m/%d/%Y"
        )
        addr_select_vend_nbr = inv.find(
            "exl:vendor_additional_code", NSP
        ).text.replace(" ", "")
        pmt_remit_nm = " " * 40
        pmt_remit_line_1_addr = " " * 40
        pmt_remit_line_2_addr = " " * 40
        pmt_remit_line_3_addr = " " * 40
        pmt_remit_city_nm = " " * 40
        pmt_remit_st_cd = " " * 2
        pmt_remit_zip_cd = " " * 11
        pmt_remit_cntry_cd = " " * 2
        vend_st_res_ind = " "
        inv_received_dt = " " * 8
        note_list = inv.find("exl:noteList", NSP)
        if note_list is None:
            create_dt = inv.find("exl:invoice_ownered_entity/exl:creationDate", NSP)
            if create_dt is None:
                goods_received_dt = " " * 8
            else:
                goods_received_dt = create_dt.text
            attachment_req_ind = 'N'
        else:
            goods_received_dt = note_list.find(
                "exl:note/exl:owneredEntity/exl:creationDate", NSP
            ).text
            if note_list.find("exl:note/exl:content", NSP).text == "ATTACHMENT":
                attachment_req_ind = 'Y'
            else:
                attachment_req_ind = 'N'
        org_shp_zip_cd = CONFIG.get("apfeed", "org_shp_zip_cd")
        org_shp_state_cd = CONFIG.get("apfeed", "org_shp_state_cd")
        pmt_grp_cd = CONFIG.get("apfeed", "pmt_grp_cd")
        inv_fob_cd = " " * 2
        disc_term_cd = " " * 2
        scheduled_pmt_dt = self.now.strftime("%Y%m%d")
        pmt_non_check_ind = CONFIG.get("apfeed", "pmt_non_check_ind")
        fin_coa_cd = CONFIG.get("apfeed", "fin_coa_cd")
        sub_acct_nbr = " " * 5
        fin_object_cd = CONFIG.get('apfeed', 'fin_object_cd')
        fin_sub_obj_cd = " " * 3
        project_cd = " " * 10
        vat_amt = float(
            inv.find("exl:vat_info/exl:vat_amount", NSP).text
        )
        pmt_tax_cd_inv = 'A' if vat_amt > 0 else '0'
        apply_disc_ind = CONFIG.get('apfeed', 'apply_disc_ind')
        eft_override_ind = CONFIG.get('apfeed', 'eft_override_ind')
        ap_pmt_purpose_desc = " " * 120
        inv_list = inv.findall("./exl:invoice_line_list/exl:invoice_line", NSP)

        # Validate
        # Cannot have invoice date in the future
        if vend_assign_inv_date.date() > self.now.date():
            logging.warn("Skipping(%s) Invoice date(%s) is in the future",vend_assign_inv_nbr ,vend_assign_inv_date)
            self.errors += 1
            return

        for inv_line in inv_list:
            pmt_line_nbr = int(inv_line.find("exl:line_number", NSP).text)
            logging.debug("- Line Number: %s", pmt_line_nbr)
            account_nbr = inv_line.find(
                "exl:fund_info_list/exl:fund_info/exl:external_id",
                NSP
            ).text
            po_line_nbr = inv_line.find(
                "exl:po_line_info/exl:po_line_number",
                NSP
            )
            if po_line_nbr is None:
                org_reference_id = " " * 8
            else:
                org_reference_id = strstr(po_line_nbr.text, '-')
            pmt_amt = int(float(
                inv_line.find(
                    "exl:fund_info_list/exl:fund_info/exl:amount/exl:sum",
                    NSP
                ).text
            ) * 100)
            note = inv_line.find("exl:note", NSP)
            if note is not None and re.match(r"^UTAX",note.text):
                pmt_tax_cd = 'C'
            else:
                pmt_tax_cd = pmt_tax_cd_inv

            #FIXME Eventually move this to a class
            # Validate
            if pmt_tax_cd == 'B' or pmt_tax_cd == 'C':
                if (not goods_received_dt.strip()
                        or not org_shp_zip_cd.strip()
                        or not org_shp_state_cd.strip()):
                    logging.warn("Conditionally required field is empty:"
                                  "GOODS_RECEIVED_DT, ORG_SHP_ZIP_CD and "
                                  "ORG_SHP_STATE_CD required when PMT_TAX_CD"
                                  " is B or C - for invoice: %s", vend_assign_inv_nbr)
                    self.errors += 1
                    return

            istr = "GENERALLIBRARY "
            istr += self.now.strftime("%Y%m%d%H%M%S")
            istr += "{:07d}".format(self.org_doc_nbr)
            istr += self.emp_ind
            istr += vend_nbr[0:10]
            istr += "{:15}".format(vend_assign_inv_nbr[0:15])
            istr += vend_assign_inv_date.strftime("%Y%m%d")
            istr += addr_select_vend_nbr
            istr += pmt_remit_nm
            istr += pmt_remit_line_1_addr
            istr += pmt_remit_line_2_addr
            istr += pmt_remit_line_3_addr
            istr += pmt_remit_city_nm
            istr += pmt_remit_st_cd
            istr += pmt_remit_zip_cd
            istr += pmt_remit_cntry_cd
            istr += vend_st_res_ind
            istr += inv_received_dt
            istr += goods_received_dt[0:8]
            istr += org_shp_zip_cd[0:11]
            istr += " "
            istr += org_shp_state_cd[0:2]
            istr += pmt_grp_cd
            istr += inv_fob_cd
            istr += disc_term_cd
            istr += " "
            istr += scheduled_pmt_dt
            istr += pmt_non_check_ind
            istr += attachment_req_ind
            istr += "{:05d}".format(pmt_line_nbr)
            istr += fin_coa_cd
            istr += " "
            istr += account_nbr[0:7]
            istr += sub_acct_nbr
            istr += fin_object_cd
            istr += fin_sub_obj_cd
            istr += project_cd
            istr += "{:8}".format(org_reference_id[0:8])
            istr += pmt_tax_cd
            istr += "{:012d}".format(pmt_amt)
            istr += apply_disc_ind
            istr += eft_override_ind
            istr += ap_pmt_purpose_desc

            self.invoices.append(istr)
            self.count += 1


    def to_string(self):
        """To string format which can be printed"""
        out = "**HEADERLGGENERALLIBRARY %s\n" % self.now.strftime(
            "%Y%m%d%H%M%S"
        )
        out += "\n".join(self.invoices)
        out += "\n**TRAILERGENERALLIBRARY %06d" % self.count
        return out


def xml_to_invoices(input_file):
    """
    Using Element tree to parse input xml into Element trees
    """
    out = []
    with open(input_file, 'r') as xfh:
        data = ET.parse(xfh).getroot()
        for inv in data.findall(".//exl:invoice", NSP):
            out.append(inv)
    return out

# pylint: disable=C0103
if __name__ == "__main__":
    # Constants
    mytime = int(time.time())
    cwd = os.getcwd()
    tmp_dir = "/tmp"

    # parse command line arguments
    parser = argparse.ArgumentParser(
        description='Import/Translate/Upload XML files to text files.'
                    ' Transfer those files to the target server via'
                    ' SCP for processing by Finance.'
    )

    parser.add_argument('-i', '--input-file')
    parser.add_argument(
        '-l', '--log-file',
        default="xml_to_apfeed.%d.log" % mytime,
        help='logfile name (default: xml_to_apfeef.<time>.log)'
    )
    parser.add_argument(
        '--log-dir',
        default=os.path.join(cwd, "logs"),
        help='log directory (default: <cwd>/logs)'
    )
    parser.add_argument(
        '--log-level',
        default='INFO',
        help='log level of written log (default: INFO) Possible '
             '[DEBUG, INFO, WARNING, ERROR, CRITICAL]'
    )
    parser.add_argument(
        '-a', '--apfeed-file',
        default="apfeed.LG.%s" % datetime.datetime.now().strftime(
            '%Y%m%d%H%M%S'
        ),
        help='output file name of apfeed file (default:apfeed.LG.<time>)'
    )
    parser.add_argument(
        '--no-upload',
        action='store_true',
        default=False,
        help='Tells xml_to_apfeed not to upload the apfeed'
             ' file to kfs (default:False)')
    parser.add_argument(
        '-x', '--xml-dir',
        default=os.path.join(cwd, "xml"),
        help='Directory where it will try to ingest'
             ' the xml files from. (default:<cwd>/xml)')
    parser.add_argument(
        '--archive-dir',
        default=os.path.join(cwd, "archive"),
        help='Directory where xml_to_apfeed will'
        ' archive xmls and apfeed (default:<cwd>/archive)'
    )
    parser.add_argument(
        '--apfeed-dir',
        default=os.path.join(cwd, "apfeed"),
        help='Directory where xml_to_apfeed will'
        ' create apfeed file before upload(default:<cwd>/apfeed)'
    )
    args = parser.parse_args()

    # Create and setup logging
    latest_log = os.path.join(args.log_dir, "xml_to_apfeed.latest.log")
    if not os.path.isdir(args.log_dir):
        os.mkdir(args.log_dir)
    log_file_path = os.path.join(args.log_dir, args.log_file)

    # Create and setup apfeed dir
    apfeed_dir = args.apfeed_dir
    if not os.path.isdir(apfeed_dir):
        os.mkdir(apfeed_dir)
    apfeed_file_path = os.path.join(apfeed_dir, args.apfeed_file)

    # Create and setup archive
    archive_dir = args.archive_dir
    if not os.path.isdir(archive_dir):
        os.mkdir(archive_dir)
    xml_arch_dir = os.path.join(archive_dir, "xml")
    if not os.path.isdir(xml_arch_dir):
        os.mkdir(xml_arch_dir)
    apfeed_arch_dir = os.path.join(archive_dir, "apfeed")
    if not os.path.isdir(apfeed_arch_dir):
        os.mkdir(apfeed_arch_dir)

    numeric_level = getattr(logging, args.log_level.upper(), None)
    if not isinstance(numeric_level, int):
        raise ValueError('Invalid log level: %s' % args.log_level)
    logging.basicConfig(filename=log_file_path,
                        level=numeric_level)
    logging.getLogger().addHandler(logging.StreamHandler())

    # If input file is not selected we check all files in xml/
    xmls = []
    if args.input_file is None:
        xml_dir = args.xml_dir
        for xml_file in os.listdir(xml_dir):
            if xml_file.endswith(".xml"):
                xmls.append(os.path.join(xml_dir, xml_file))
    else:
        xmls = [args.input_file]

    if not xmls:
        logging.info("No XMLs Dectected")
        sys.exit(0)

    # Start building Apfeed file
    apf = Apfeed()

    for xml in xmls:
        logging.info("Processing %s", xml)
        # Start reading the xml file for invoices
        invoices = xml_to_invoices(xml)

        # Add invoices to apfeed file
        for invoice in invoices:
            apf.add_inv(invoice)

        # Move XML to archive/xml
        shutil.move(xml, xml_arch_dir)

    # Write the file
    logging.info("Writing %s", apfeed_file_path)
    with open(apfeed_file_path, 'wb') as apfeed_file:
        apfeed_file.write(apf.to_string())

    # Upload to server
    server = CONFIG.get("apfeed_scp_out", "server")
    user = CONFIG.get("apfeed_scp_out", "user")
    private_key = CONFIG.get("apfeed_scp_out", "private_key")

    if not args.no_upload and apf.errors == 0:
        logging.info("Uploading via SCP")
        ssh = create_ssh_client(server, user, private_key)
        scp = SCPClient(ssh.get_transport())
        scp.put(apfeed_file_path)
        logging.info("Uploaded: %s", apfeed_file_path)
        shutil.move(apfeed_file_path, apfeed_arch_dir)
        logging.info("Moved %s to %s", apfeed_file_path, apfeed_arch_dir)
    elif apf.errors > 0:
        logging.info("Not uploading because there were %d errors", apf.errors)

    # Update config.ini for org_doc_nbr
    CONFIG.set("apfeed", "org_doc_nbr", apf.org_doc_nbr)
    with open("config.ini", 'wb') as config_file:
        CONFIG.write(config_file)

    # set current log as latest log
    if os.path.lexists(latest_log):
        os.unlink(latest_log)
    os.symlink(log_file_path, latest_log)
